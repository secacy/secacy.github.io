---
title: OSTEP 第二章笔记
date: 2025-09-28 #HH:MM:SS +/-TTTT
categories: [OS]
tags: []     # TAG names should always be lowercase
description: ch2 操作系统介绍笔记梳理
---

一个正在运行的程序会：执行指令（fetch - decode - execute)

- decode(解码) → （弄清楚这是哪条指令）

一个程序运行的同时，还有很多其它疯狂的事情也在同步进行。



操作系统（Operating System，OS）负责让程序运行变得容易（甚至允许你同时允许多个程序），允许程序共享内存，让程序能够与设备交互，以及其它有趣的工作。

操作系统负责确保系统既易于使用又正确高效地运行。



## 操作系统的别名

**虚拟机**

操作系统将物理资源转换为更通用、更强大且更易于使用的虚拟形式  → 虚拟化

- 物理资源（如处理器、内存或磁盘）

**为应用程序提供标准库**

操作系统提供了一些接口（API）来告诉用户它可以做什么  → 系统调用(system call)

**资源管理器**

虚拟化

- 让许多程序运行（从而共享CPU）
- 让许多程序可以同时访问自己的指令和数据（从而共享内存）
- 让许多程序访问设备（从而共享磁盘等）

每个CPU、内存和磁盘都是系统的资源，因此操作系统扮演的主要角色就是管理这些资源。



## 虚拟化

**虚拟化CPU**

将单个CPU（或其中一小部分）转换为看似无限数量的CPU，从而让许多程序看似同时运行 → 虚拟化CPU

**虚拟化内存**

物理内存模型

- 内存就是一个字节数组
- 要读取内存，必须指定一个地址，才能访问存储在那里的数据
- 要写入或更新内存，还必须指定要写入给定地址的数据

程序运行时，要一直访问内存

- 程序将所有数据结构保存在内存中，并通过各种指令来访问它们
- 不要忘记，程序的每个指令都在内存中，因此每次读取指令都会访问内存

虚拟化内存

- 每个进程都有自己的私有的虚拟地址空间，操作系统以某种方式将其映射到机器的物理内存上
  - 虚拟地址空间有时称为地址空间
- 一个正在运行的程序中的内存引用不会影响其它进程（或操作系统本身）的地址空间
- 在正在运行的程序看来，它完全拥有自己的物理内存，但事实上，物理内存是由操作系统管理的共享资源



## 并发

并发（concurrency）

并发问题在同时（并发地）处理很多事情时出现且必须解决。

并发问题出现在操作系统本身中。

并发问题也出现在多线程程序中。



counter++，它需要3条指令：

1. 将值从内存加载到寄存器
2. 将其自增
3. 将其保存回内存



## 持久性

在系统内存中，数据容易丢失，因为像 DRAM 这样的设备以易失（volatile）的方式存储数值。如果断电或系统崩溃，那么内存中的所有数据都会丢失。

文件系统 → 操作系统中管理磁盘的软件

文件系统是操作系统的一部分，负责管理持久的数据。

出于性能方面的原因，大多数文件系统首先会延迟这些写操作一段时间，希望将其批量分组为较大的组。

为了处理写入期间系统崩溃的问题，大多数文件系统都包含某种复杂的写入协议，如日志（journaling）或写时复制（copy-on-write），仔细排序写入磁盘的操作，以确保如果在写入序列期间发生故障，系统可以在之后恢复到合理的状态。

为了使不同的通用操作更高效，文件系统采用了许多不同的数据结构和访问方法，从简单的列表到复杂的B树。



## 设计目标

操作系统做了什么：

- 它取得CPU、内存或磁盘等物理资源，并对它们进行虚拟化
- 它处理与并发有关的麻烦且棘手的问题
- 它持久地存储文件，从而使它们长期安全

操作系统的设计目标：

- 建立一些**抽象**，让系统便于且易于使用

- 提供高性能

  - 最小化操作系统的开销
  - 开销 → 额外时间（更多指令）和额外空间（内存或磁盘上）

- 在应用程序之间以及在 OS 和应用程序之间提供保护

  - 让进程彼此隔离是保护的关键

- 高度的可靠性、安全性、移动性…

操作系统的简单历史

- 早期操作系统：只是一些库
- 超越库：保护
  - system call 诞生了
    - 用户模式和内核模式
    - 系统调用将控制转移到(i.e. 跳转到) OS 中，同时提高硬件特权级别
- 多道程序时代
  - 操作系统不是一次只允许一项作业，而是将大量作业加载到内存中并在它们之间快速切换，从而提高CPU利用率
    - 因为 IO 设备很慢，如果在处理 IO 时让程序占着 CPU 会浪费 CPU时间
  - 内存保护问题、并发问题…
  - 在中断存在的情况下，要确保操作系统正常运行
- 摩登时代



> 在发起系统调用时（通常通过陷阱(trap)特殊硬件指令），硬件将控制转移到预先指定的陷阱处理程序(trap handler)，同时将特权级别提升到内核模式。 
> 
> 当操作者系统完成请求的服务时，它通过特殊的陷阱返回(return-from-trap)指令将控制权交还给应用程序，回到应用离开的地方。
{: .prompt-info }

> 最初的 “Bell Labs” Unix 的基础是统一的原则：
>
> 构建小而强大的程序，这些程序可以连接在一起形成更大的工作流
{: .prompt-info }
